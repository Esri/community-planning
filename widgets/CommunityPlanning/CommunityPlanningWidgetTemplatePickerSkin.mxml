<?xml version="1.0" encoding="utf-8"?>
<!--
 | Version 10.1.1
 | Copyright 2010 Esri
 |
 | Licensed under the Apache License, Version 2.0 (the "License");
 | you may not use this file except in compliance with the License.
 | You may obtain a copy of the License at
 |
 |    http://www.apache.org/licenses/LICENSE-2.0
 |
 | Unless required by applicable law or agreed to in writing, software
 | distributed under the License is distributed on an "AS IS" BASIS,
 | WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 | See the License for the specific language governing permissions and
 | limitations under the License.
-->
<!---
Custom skin class for the TemplatePicker component.
-->
<s:SparkSkin xmlns:fx="http://ns.adobe.com/mxml/2009"
			 xmlns:s="library://ns.adobe.com/flex/spark"
			 xmlns:mx="library://ns.adobe.com/flex/mx"
			 initialize="sparkskin1_initializeHandler(event)">

	<!-- host component -->
	<fx:Metadata>
		/**
		* A strongly typed property that references the component to which this skin is applied.
		*/
		[HostComponent("com.esri.ags.components.TemplatePicker")]
	</fx:Metadata>

	<s:states>
		<s:State name="normal"/>
		<s:State name="disabled"/>
		<s:State name="loading" />
	</s:states>

	<s:layout>
		<s:VerticalLayout horizontalAlign="center" clipAndEnableScrolling="true" />
	</s:layout>

	<fx:Script>
		<![CDATA[
			import com.esri.ags.components.supportClasses.Template;
			import com.esri.ags.events.LayerEvent;
			import com.esri.ags.layers.FeatureLayer;

			import flash.text.engine.FontPosture;

			import mx.binding.utils.ChangeWatcher;
			import mx.collections.ArrayCollection;
			import mx.controls.Label;
			import mx.controls.Text;
			import mx.events.FlexEvent;

			import spark.components.CheckBox;
			import spark.components.List;
			import spark.components.Scroller;
			import spark.events.IndexChangeEvent;
			import spark.layouts.TileLayout;


			private var _changeWatcher:ChangeWatcher;
			private var _templateCollectionChanged:Boolean;
			private var _selectedTemplateChanged:Boolean;
			private var _skinSelectedTemplate:Template;
			private var _currentList:List;

			private var _selectedTemplateChangeWatcher:ChangeWatcher;
			private var _templatePickerListItemRenderer:ClassFactory = new ClassFactory(CommunityPlanningWidgetTemplatePickerListItemRenderer);
			private var _itemRenderer:CommunityPlanningWidgetTemplatePickerListItemRenderer = new CommunityPlanningWidgetTemplatePickerListItemRenderer();

			// configurable through the edit widget's config file
			public static var featureLayerNotVisibleText:String;

			private function sparkskin1_initializeHandler(event:FlexEvent):void
			{
				_changeWatcher = ChangeWatcher.watch(hostComponent, "templateCollection", templateCollectionChangeHandler);
				_selectedTemplateChangeWatcher = ChangeWatcher.watch(hostComponent, "selectedTemplate", selectTemplateChangeWatcher);
			}

			private function templateCollectionChangeHandler(event:Event = null):void
			{
				invalidateProperties();
				_templateCollectionChanged = true;
			}

			private function selectTemplateChangeWatcher(event:Event = null):void
			{
				invalidateProperties();
				_selectedTemplateChanged = true;
			}

			/**
			 * @private
			 */
			override protected function commitProperties():void
			{
				super.commitProperties();

				if (_templateCollectionChanged)
				{
					_templateCollectionChanged = false;

					//First remove everything from the group
					vGrp.removeAllElements();

					//create list and label for each featureLayer
					for (var i:Number = 0; i < hostComponent.templateCollection.length; i++)
					{
						FeatureLayer(hostComponent.templateCollection[i].featureLayer).removeEventListener(FlexEvent.HIDE, featureLayer_hideShowHandler);
						FeatureLayer(hostComponent.templateCollection[i].featureLayer).removeEventListener(FlexEvent.SHOW, featureLayer_hideShowHandler);
						FeatureLayer(hostComponent.templateCollection[i].featureLayer).removeEventListener(LayerEvent.IS_IN_SCALE_RANGE_CHANGE, featureLayer_isInScaleRangeChangeHandler);

						FeatureLayer(hostComponent.templateCollection[i].featureLayer).addEventListener(FlexEvent.HIDE, featureLayer_hideShowHandler);
						FeatureLayer(hostComponent.templateCollection[i].featureLayer).addEventListener(FlexEvent.SHOW, featureLayer_hideShowHandler);
						FeatureLayer(hostComponent.templateCollection[i].featureLayer).addEventListener(LayerEvent.IS_IN_SCALE_RANGE_CHANGE, featureLayer_isInScaleRangeChangeHandler);

						var templateList:List = new List;
						templateList.scroller = new Scroller();


						templateList.name = hostComponent.templateCollection[i].featureLayer.layerDetails.name;
						templateList.addEventListener(IndexChangeEvent.CHANGE, listChangeHandler, false, -1, true);
						templateList.dataProvider = new ArrayCollection(hostComponent.templateCollection[i].selectedTemplates);
						templateList.itemRenderer = _templatePickerListItemRenderer;

						// style and layout
						templateList.setStyle("borderVisible", false);

						const verticleLayout:VerticalLayout = new VerticalLayout();
						verticleLayout.gap = 0;
						templateList.layout = verticleLayout;

						templateList.setStyle("skinClass", Class(CommunityPlanningListSkin));

						vGrp.addElement(templateList);



						if (!FeatureLayer(hostComponent.templateCollection[i].featureLayer).isInScaleRange)
						{
							templateList.visible = false;
							templateList.includeInLayout = true;
						}

						var text:Text = new Text;
						text.percentWidth = 100;
						text.name = hostComponent.templateCollection[i].featureLayer.layerDetails.name;
						text.text = hostComponent.templateCollection[i].featureLayer.layerDetails.name + " " + featureLayerNotVisibleText;
						text.setStyle("fontStyle", FontPosture.ITALIC);

						text.visible = !FeatureLayer(hostComponent.templateCollection[i].featureLayer).isInScaleRange;
						text.includeInLayout = !FeatureLayer(hostComponent.templateCollection[i].featureLayer).isInScaleRange;

						vGrp.addElement(text);
					}
					invalidateDisplayList();
					selectTemplatFromList();
				}

				if (_selectedTemplateChanged)
				{
					_selectedTemplateChanged = false;
					selectTemplatFromList()
				}


			}

			private function checkBoxSelectionChangeHandler(event:Event):void
			{
				// loop through the featureLayers and make them visible
				for (var i:Number = 0; i < hostComponent.templateCollection.length; )
				{
					if (hostComponent.templateCollection[i].featureLayer.layerDetails.name == event.target.label)
					{
						hostComponent.templateCollection[i].featureLayer.visible = event.target.selected;
						break;
					}
					else
					{
						i++;
					}
				}
			}

			/**
			 * @private
			 */
			override protected function updateDisplayList(unscaledWidth:Number, unscaledHeight:Number):void
			{
				super.updateDisplayList(unscaledWidth, unscaledHeight);

				var templatesPerList:int;

				for (var i:Number = 0; i < vGrp.numElements; i++)
				{
					if (vGrp.getElementAt(i) is List)
					{
						List(vGrp.getElementAt(i)).percentWidth = 100;

						templatesPerList = List(vGrp.getElementAt(i)).dataProvider.length;

					}
				}
				vGrp.invalidateSize();
			}

			private function selectTemplatFromList():void
			{
				if (!hostComponent.templateCollection)
				{
					// Do nothing -  as there is no collection.
				}
				else if (hostComponent.selectedTemplate == _skinSelectedTemplate)
				{
					// Do nothing -  as the template is already selected and is same as hostComponent.selectedTemplate.
				}
				else if (!hostComponent.selectedTemplate)
				{
					// clear selection is called
					_skinSelectedTemplate = null;
					for (var i:Number = 0; i < vGrp.numElements; i++)
					{
						if (vGrp.getElementAt(i) is List)
						{
							if (List(vGrp.getElementAt(i)).selectedIndex != -1)
							{
								List(vGrp.getElementAt(i)).selectedIndex = -1;
							}
						}
					}
				}
				else
				{
					for (var k:Number = 0; k < vGrp.numElements; k++)
					{
						if (vGrp.getElementAt(k) is List)
						{
							for (var n:Number = 0; n < List(vGrp.getElementAt(k)).dataProvider.length; n++)
							{
								if ((List(vGrp.getElementAt(k)).dataProvider.getItemAt(n).featureLayer === hostComponent.selectedTemplate.featureLayer) &&
									(List(vGrp.getElementAt(k)).dataProvider.getItemAt(n).featureType === hostComponent.selectedTemplate.featureType) &&
									(List(vGrp.getElementAt(k)).dataProvider.getItemAt(n).featureTemplate === hostComponent.selectedTemplate.featureTemplate))
								{
									List(vGrp.getElementAt(k)).selectedIndex = n;
									_skinSelectedTemplate = hostComponent.selectedTemplate;
								}
							}
						}
					}
				}
			}

			private function featureLayer_hideShowHandler(event:FlexEvent):void
			{
				enableDisableList(event.target as FeatureLayer);
			}

			private function featureLayer_isInScaleRangeChangeHandler(event:LayerEvent):void
			{
				enableDisableList(event.target as FeatureLayer);
			}

			private function enableDisableList(featureLayer:FeatureLayer):void
			{
				for (var i:Number = 0; i < vGrp.numElements; i++)
				{
					if (vGrp.getElementAt(i) is List && List(vGrp.getElementAt(i)).name == featureLayer.layerDetails.name)
					{
						const list:List = List(vGrp.getElementAt(i));
						list.visible = featureLayer.isInScaleRange && featureLayer.visible;
						list.includeInLayout = featureLayer.isInScaleRange && featureLayer.visible;
					}
					if (vGrp.getElementAt(i) is CheckBox && CheckBox(vGrp.getElementAt(i)).label == featureLayer.layerDetails.name)
					{
						const checkBox:CheckBox = CheckBox(vGrp.getElementAt(i));
						checkBox.selected = featureLayer.isInScaleRange && featureLayer.visible;
					}
					if (vGrp.getElementAt(i) is Label && Label(vGrp.getElementAt(i)).name == featureLayer.layerDetails.name)
					{
						const label:Label = Label(vGrp.getElementAt(i));
						label.visible = !featureLayer.isInScaleRange || !featureLayer.visible;
						label.includeInLayout = !featureLayer.isInScaleRange || !featureLayer.visible;
					}
				}
				invalidateDisplayList();
			}

			private function listChangeHandler(event:IndexChangeEvent):void
			{
				vGrp.removeEventListener(MouseEvent.MOUSE_DOWN, vGrp_mouseDownHandler);
				callLater(addListener);

				if (event.newIndex != -1)
				{
					_currentList = List(event.target);

					_skinSelectedTemplate = List(event.target).selectedItem;
					hostComponent.selectedTemplate = _skinSelectedTemplate;

					for (var i:Number = 0; i < vGrp.numElements; i++)
					{
						if (vGrp.getElementAt(i) is List)
						{
							if (List(vGrp.getElementAt(i)) !== _currentList)
							{
								List(vGrp.getElementAt(i)).selectedIndex = -1;
							}
						}
					}
				}
				else
				{
					// no template selected
					if (hostComponent.selectedTemplate)
					{
						for (var j:Number = 0; j < vGrp.numElements; j++)
						{
							if (vGrp.getElementAt(j) is List)
							{
								// user deselected template on the list
								if (List(event.target) === _currentList)
								{
									_skinSelectedTemplate = null;
									hostComponent.selectedTemplate = null;
								}
							}
						}
					}
				}
			}

			private function addListener():void
			{
				vGrp.addEventListener(MouseEvent.MOUSE_DOWN, vGrp_mouseDownHandler);
			}

			private function vGrp_mouseDownHandler(event:MouseEvent):void
			{
				if (event.target is CommunityPlanningWidgetTemplatePickerListItemRenderer)
				{
					if (hostComponent.selectedTemplate && List(CommunityPlanningWidgetTemplatePickerListItemRenderer(event.target).owner).selectedItem == hostComponent.selectedTemplate) // shows a template already selected, hence clear selection
					{
						hostComponent.clearSelection();
					}
				}
				else
				{
					hostComponent.clearSelection();
				}
			}
		]]>
	</fx:Script>

	<!--- @private -->
	<s:Scroller id="scroller" width="100%" height="100%"
				horizontalScrollPolicy="auto" verticalScrollPolicy="auto"
				>
		<s:Group>
			<s:VGroup id="vGrp" gap="0"
					  width="100%" height="100%"/>
		</s:Group>

	</s:Scroller>

</s:SparkSkin>
